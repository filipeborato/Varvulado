// --------------------
// Source/PluginEditor.cpp
// --------------------
#include "PluginEditor.h"

#if __has_include("BinaryData.h")
#include "BinaryData.h"
#define HAS_BINARY_LOGO 1
#else
#define HAS_BINARY_LOGO 0
#endif

TubePreampPluginAudioProcessorEditor::TubePreampPluginAudioProcessorEditor(
    TubePreampPluginAudioProcessor& p, juce::AudioProcessorValueTreeState& vts)
    : AudioProcessorEditor(&p), processor(p), state(vts)
{
    setSize(400, 300);

    // Try to load logo image from binary resources first, fallback to file
    // BinaryData is generated by Projucer when resource="1" in the .jucer
   #if HAS_BINARY_LOGO
    {
        int dataSize = 0;
        if (const void* data = BinaryData::getNamedResource("logo_png", dataSize))
        {
            juce::MemoryInputStream mis(data, static_cast<size_t>(dataSize), false);
            logo = juce::ImageFileFormat::loadFrom(mis);
        }
    }
   #endif

    auto loadImageFromFile = [](const juce::File& f) -> juce::Image {
        if (f.existsAsFile())
        {
            juce::FileInputStream fis(f);
            if (fis.openedOk())
                return juce::ImageFileFormat::loadFrom(fis);
        }
        return {};
    };

    // Common candidate locations for development time
    const juce::String relPath = "resources/logo.png";
    if (! logo.isValid())
        logo = loadImageFromFile(juce::File::getCurrentWorkingDirectory().getChildFile(relPath));
    if (! logo.isValid())
        logo = loadImageFromFile(juce::File::getCurrentWorkingDirectory().getParentDirectory().getChildFile(relPath));
    if (! logo.isValid())
    {
        auto appDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
        logo = loadImageFromFile(appDir.getChildFile(relPath));
        if (! logo.isValid())
            logo = loadImageFromFile(appDir.getParentDirectory().getChildFile(relPath));
    }

    // Drive Slider
    driveSlider.setSliderStyle(juce::Slider::Rotary);
    driveSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 20);
    addAndMakeVisible(driveSlider);
    driveAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "drive", driveSlider);

    // Drive Label
    driveLabel.setText("DRIVE", juce::dontSendNotification);
    driveLabel.setJustificationType(juce::Justification::centred);
    driveLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(driveLabel);

    // Output Slider
    outputSlider.setSliderStyle(juce::Slider::Rotary);
    outputSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 20);
    addAndMakeVisible(outputSlider);
    outputAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "output", outputSlider);

    // Output Label
    outputLabel.setText("OUTPUT", juce::dontSendNotification);
    outputLabel.setJustificationType(juce::Justification::centred);
    outputLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(outputLabel);

    // Bias Slider
    biasSlider.setSliderStyle(juce::Slider::Rotary);
    biasSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 20);
    addAndMakeVisible(biasSlider);
    biasAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "bias", biasSlider);

    // Bias Label
    biasLabel.setText("BIAS", juce::dontSendNotification);
    biasLabel.setJustificationType(juce::Justification::centred);
    biasLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(biasLabel);
}

TubePreampPluginAudioProcessorEditor::~TubePreampPluginAudioProcessorEditor() {}

void TubePreampPluginAudioProcessorEditor::paint(juce::Graphics& g) {
    g.fillAll(juce::Colours::darkgrey);
    g.setColour(juce::Colours::white);
    g.setFont(20.0f);
    g.drawFittedText("Tube Preamp 610", 0, 10, getWidth(), 30, juce::Justification::centred, 1);
}

void TubePreampPluginAudioProcessorEditor::paintOverChildren(juce::Graphics& g)
{
    if (logo.isValid())
    {
        const int margin = 8;
        auto bounds = getLocalBounds();

        const int imgW = logo.getWidth();
        const int imgH = logo.getHeight();

        const int maxW = juce::jmin(100, bounds.getWidth() / 3);
        const int maxH = juce::jmin(50, bounds.getHeight() / 4);

        const float scale = std::min(maxW / (float) imgW, maxH / (float) imgH);
        const int drawW = juce::jmax(1, (int) std::round(imgW * scale));
        const int drawH = juce::jmax(1, (int) std::round(imgH * scale));

        const int x = bounds.getRight() - drawW - margin;
        const int y = bounds.getBottom() - drawH - margin;

        g.setOpacity(1.0f);
        g.drawImage(logo, x, y, drawW, drawH, 0, 0, imgW, imgH, false);
    }
}

void TubePreampPluginAudioProcessorEditor::resized() {
    auto area = getLocalBounds().reduced(20).removeFromBottom(220);
    
    // Drive section
    auto driveArea = area.removeFromLeft(120).reduced(10);
    driveLabel.setBounds(driveArea.removeFromTop(20));
    driveSlider.setBounds(driveArea);
    
    // Output section
    auto outputArea = area.removeFromLeft(120).reduced(10);
    outputLabel.setBounds(outputArea.removeFromTop(20));
    outputSlider.setBounds(outputArea);
    
    // Bias section
    auto biasArea = area.removeFromLeft(120).reduced(10);
    biasLabel.setBounds(biasArea.removeFromTop(20));
    biasSlider.setBounds(biasArea);
}
