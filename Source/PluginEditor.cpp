// --------------------
// Source/PluginEditor.cpp
// --------------------
#include "PluginEditor.h"

#if __has_include("BinaryData.h")
#include "BinaryData.h"
#define HAS_BINARY_LOGO 1
#else
#define HAS_BINARY_LOGO 0
#endif

TubePreampPluginAudioProcessorEditor::TubePreampPluginAudioProcessorEditor(
    TubePreampPluginAudioProcessor& p, juce::AudioProcessorValueTreeState& vts)
    : AudioProcessorEditor(&p), processor(p), state(vts)
{
    setSize(400, 340);

    // Try to load logo image from binary resources first, fallback to file
    // BinaryData is generated by Projucer when resource="1" in the .jucer
   #if HAS_BINARY_LOGO
    {
        int dataSize = 0;
        if (const void* data = BinaryData::getNamedResource("logo_png", dataSize))
        {
            juce::MemoryInputStream mis(data, static_cast<size_t>(dataSize), false);
            logo = juce::ImageFileFormat::loadFrom(mis);
        }
    }
   #endif

    auto loadImageFromFile = [](const juce::File& f) -> juce::Image {
        if (f.existsAsFile())
        {
            juce::FileInputStream fis(f);
            if (fis.openedOk())
                return juce::ImageFileFormat::loadFrom(fis);
        }
        return {};
    };

    // Common candidate locations for development time
    const juce::String relPath = "resources/logo.png";
    if (! logo.isValid())
        logo = loadImageFromFile(juce::File::getCurrentWorkingDirectory().getChildFile(relPath));
    if (! logo.isValid())
        logo = loadImageFromFile(juce::File::getCurrentWorkingDirectory().getParentDirectory().getChildFile(relPath));
    if (! logo.isValid())
    {
        auto appDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
        logo = loadImageFromFile(appDir.getChildFile(relPath));
        if (! logo.isValid())
            logo = loadImageFromFile(appDir.getParentDirectory().getChildFile(relPath));
    }

    // Drive Slider
    driveSlider.setSliderStyle(juce::Slider::Rotary);
    driveSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 16);
    addAndMakeVisible(driveSlider);
    driveAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "drive", driveSlider);

    // Drive Label
    driveLabel.setText("DRIVE", juce::dontSendNotification);
    driveLabel.setJustificationType(juce::Justification::centred);
    driveLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(driveLabel);

    // Output Slider
    outputSlider.setSliderStyle(juce::Slider::Rotary);
    outputSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 16);
    addAndMakeVisible(outputSlider);
    outputAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "output", outputSlider);

    // Output Label
    outputLabel.setText("OUTPUT", juce::dontSendNotification);
    outputLabel.setJustificationType(juce::Justification::centred);
    outputLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(outputLabel);

    // Bias Slider
    biasSlider.setSliderStyle(juce::Slider::Rotary);
    biasSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 16);
    addAndMakeVisible(biasSlider);
    biasAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "bias", biasSlider);

    // Bias Label
    biasLabel.setText("BIAS", juce::dontSendNotification);
    biasLabel.setJustificationType(juce::Justification::centred);
    biasLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(biasLabel);
}

TubePreampPluginAudioProcessorEditor::~TubePreampPluginAudioProcessorEditor() {}

void TubePreampPluginAudioProcessorEditor::paint(juce::Graphics& g) {
    // Ensure/paint velvet background
    if (velvetBackground.getWidth() != getWidth() || velvetBackground.getHeight() != getHeight())
        regenerateVelvetBackground();
    if (velvetBackground.isValid())
        g.drawImageAt(velvetBackground, 0, 0);
    else
        g.fillAll(juce::Colours::darkblue.darker(0.6f));

    // Header/title area, text centered across header
    auto inner = getLocalBounds().reduced(20);
    auto header = inner.removeFromTop(120);

    g.setColour(juce::Colours::white);
    g.setFont(22.0f);
    g.drawFittedText("VARvulado", header, juce::Justification::centred, 1);
}

void TubePreampPluginAudioProcessorEditor::paintOverChildren(juce::Graphics& g)
{
    if (logo.isValid())
    {
        // Draw logo almost flush with the top-left corner
        const int margin = 1;
        auto outer = getLocalBounds();
        auto header = outer.removeFromTop(120);

        const int imgW = logo.getWidth();
        const int imgH = logo.getHeight();

        const int maxW = juce::jmin(300, (header.getWidth() * 2) / 3); // allow wider logo
        const int maxH = juce::jmax(1, header.getHeight() - 2 * margin);

        const float scale = std::min(maxW / (float) imgW, maxH / (float) imgH);
        const int drawW = juce::jmax(1, (int) std::round(imgW * scale));
        const int drawH = juce::jmax(1, (int) std::round(imgH * scale));

        const int x = header.getX() + margin;
        const int y = header.getY() + margin;

        drawLogoBlended(g, { x, y, drawW, drawH });
    }
}

void TubePreampPluginAudioProcessorEditor::resized() {
    auto bounds = getLocalBounds().reduced(20);
    auto header = bounds.removeFromTop(120); // reserved for larger logo + title
    juce::ignoreUnused(header);

    // Controls area below header
    auto area = bounds; // remaining area

    // Drive section
    auto driveArea = area.removeFromLeft(120).reduced(6);
    driveLabel.setBounds(driveArea.removeFromTop(16));
    driveSlider.setBounds(driveArea);

    // Output section
    auto outputArea = area.removeFromLeft(120).reduced(6);
    outputLabel.setBounds(outputArea.removeFromTop(16));
    outputSlider.setBounds(outputArea);

    // Bias section
    auto biasArea = area.removeFromLeft(120).reduced(6);
    biasLabel.setBounds(biasArea.removeFromTop(16));
    biasSlider.setBounds(biasArea);
}

void TubePreampPluginAudioProcessorEditor::drawLogoBlended(juce::Graphics& g, juce::Rectangle<int> dst)
{
    if (! logo.isValid())
        return;

    const int w = juce::jmax(1, dst.getWidth());
    const int h = juce::jmax(1, dst.getHeight());

    // Prepare scaled logo with high-quality resampling
    juce::Image scaled(juce::Image::ARGB, w, h, true);
    {
        juce::Graphics sg(scaled);
        sg.setImageResamplingQuality(juce::Graphics::highResamplingQuality);
        sg.drawImage(logo, juce::Rectangle<float>(0, 0, (float) w, (float) h));
    }

    // If velvet background exists, blend per-pixel to integrate tones
    const bool canBlend = velvetBackground.isValid();

    if (! canBlend)
    {
        g.drawImageAt(scaled, dst.getX(), dst.getY());
        return;
    }

    juce::Image blended(juce::Image::ARGB, w, h, true);

    for (int y = 0; y < h; ++y)
    {
        for (int x = 0; x < w; ++x)
        {
            const juce::Colour s = scaled.getPixelAt(x, y);
            const int bx = juce::jlimit(0, velvetBackground.getWidth()  - 1, dst.getX() + x);
            const int by = juce::jlimit(0, velvetBackground.getHeight() - 1, dst.getY() + y);
            const juce::Colour b = velvetBackground.getPixelAt(bx, by);

            float a = s.getFloatAlpha();
            float sr = s.getFloatRed();
            float sg = s.getFloatGreen();
            float sb = s.getFloatBlue();

            // Suppress blue fringing only near edges (very gentle)
            const float maxRG = std::max(sr, sg);
            float blueFringe = juce::jlimit(0.0f, 1.0f, (sb - maxRG - 0.08f) * 0.8f);

            // Edge metrics
            const int edgePx = 2;
            const int minEdge = std::min(std::min(x, y), std::min(w - 1 - x, h - 1 - y));
            const float edgeFactor = minEdge < edgePx ? (edgePx - (float) minEdge) / (float) edgePx : 0.0f; // 0..1
            const float edgeFeather = minEdge < 1 ? (1.0f - (float) minEdge) : 0.0f; // 0..1

            a = a * (1.0f - 0.20f * blueFringe * edgeFactor) * (1.0f - 0.04f * edgeFeather);
            a = juce::jlimit(0.0f, 1.0f, a * 1.25f + 0.08f); // stronger alpha boost with floor

            // Multiply blend to inherit velvet tone
            float br = b.getFloatRed();
            float bg = b.getFloatGreen();
            float bb = b.getFloatBlue();

            // Pre-boost logo more to avoid looking washed out
            sr = juce::jlimit(0.0f, 1.0f, sr * 1.12f + 0.02f);
            sg = juce::jlimit(0.0f, 1.0f, sg * 1.12f + 0.02f);
            sb = juce::jlimit(0.0f, 1.0f, sb * 1.12f + 0.02f);

            // Use normal blend colours (no multiply/screen) for maximum visibility
            float cr = sr;
            float cg = sg;
            float cb = sb;

            float rr = br * (1.0f - a) + cr * a;
            float rg = bg * (1.0f - a) + cg * a;
            float rb = bb * (1.0f - a) + cb * a;

            blended.setPixelAt(x, y, juce::Colour::fromFloatRGBA(rr, rg, rb, 1.0f));
        }
    }

    // Stronger backplate to seat the logo (darken background slightly)
    g.setColour(juce::Colours::black.withAlpha(0.20f));
    g.fillRoundedRectangle(dst.toFloat().expanded(2.0f), 4.0f);

    g.drawImageAt(blended, dst.getX(), dst.getY());
}

void TubePreampPluginAudioProcessorEditor::regenerateVelvetBackground()
{
    const int w = juce::jmax(1, getWidth());
    const int h = juce::jmax(1, getHeight());
    velvetBackground = juce::Image(juce::Image::RGB, w, h, true);

    // Parameters for velvet-like folds (vertical drapes)
    const int folds = 6;
    const float sigma = w / (folds * 3.0f); // width of highlights
    juce::Array<float> foldCenters;
    for (int i = 0; i < folds; ++i)
        foldCenters.add((i + 0.5f) * (w / (float) folds));

    // Precompute fold profile across X
    juce::HeapBlock<float> profile(w);
    float maxProf = 0.0f;
    for (int x = 0; x < w; ++x)
    {
        float s = 0.0f;
        for (auto c : foldCenters)
        {
            const float dx = (x - c);
            s += std::exp(-(dx * dx) / (2.0f * sigma * sigma));
        }
        profile[x] = s;
        if (s > maxProf) maxProf = s;
    }
    if (maxProf <= 0.0f) maxProf = 1.0f;

    // Deterministic seed for grain; use valid hex literal
    juce::Random rng((juce::int64) 0xB1DEA1);

    // Base and highlight colours
    const juce::Colour base = juce::Colour::fromFloatRGBA(0.03f, 0.08f, 0.26f, 1.0f); // deep blue
    const juce::Colour hi   = juce::Colour::fromFloatRGBA(0.12f, 0.22f, 0.60f, 1.0f); // highlight blue

    for (int y = 0; y < h; ++y)
    {
        // Subtle vertical gradient (vignette top/bottom)
        const float vy = (y / (float) h);
        const float vignetteY = 0.85f + 0.15f * std::cos((vy - 0.5f) * juce::MathConstants<float>::twoPi);

        for (int x = 0; x < w; ++x)
        {
            float fx = profile[x] / maxProf;              // 0..1 highlight factor
            float grain = (rng.nextFloat() - 0.5f) * 0.06f; // fine noise
            if ((y & 1) == 0) grain *= 0.6f;               // slight anisotropy

            // Sheen: simulate angle-dependent highlight
            const float sheen = 0.15f * std::sin((x * 0.012f) + (y * 0.02f));

            float shade = juce::jlimit(0.0f, 1.4f, 0.55f + 0.45f * fx);
            shade = shade * vignetteY + sheen + grain;
            shade = juce::jlimit(0.0f, 1.2f, shade);

            // Mix base and highlight by shade
            const int r = juce::jlimit(0, 255, (int) std::round(base.getRed()   * (1.0f - shade) + hi.getRed()   * shade));
            const int g = juce::jlimit(0, 255, (int) std::round(base.getGreen() * (1.0f - shade) + hi.getGreen() * shade));
            const int b = juce::jlimit(0, 255, (int) std::round(base.getBlue()  * (1.0f - shade) + hi.getBlue()  * shade));

            velvetBackground.setPixelAt(x, y, juce::Colour::fromRGB((juce::uint8) r, (juce::uint8) g, (juce::uint8) b));
        }
    }

    // Overlay a soft diagonal highlight and corner vignettes
    {
        juce::Graphics gg(velvetBackground);

        juce::ColourGradient diag(juce::Colours::transparentBlack, {0.0f, 0.0f},
                                  juce::Colour(255, 255, 255).withAlpha(0.06f), { (float) w, (float) h }, false);
        gg.setGradientFill(diag);
        gg.fillAll();

        juce::ColourGradient vign(juce::Colours::black.withAlpha(0.12f), {0.0f, 0.0f},
                                  juce::Colours::transparentBlack, { (float) w * 0.6f, (float) h * 0.6f }, true);
        gg.setGradientFill(vign);
        gg.fillEllipse(-w * 0.2f, -h * 0.2f, w * 0.8f, h * 0.8f);

        juce::ColourGradient vign2(juce::Colours::black.withAlpha(0.12f), { (float) w, (float) h },
                                   juce::Colours::transparentBlack, { (float) w * 0.4f, (float) h * 0.4f }, true);
        gg.setGradientFill(vign2);
        gg.fillEllipse(w * 0.4f, h * 0.4f, w * 0.8f, h * 0.8f);
    }
}
