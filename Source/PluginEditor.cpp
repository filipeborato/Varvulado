// --------------------
// Source/PluginEditor.cpp
// --------------------
#include "PluginEditor.h"

#if __has_include("BinaryData.h")
#include "BinaryData.h"
#define HAS_BINARY_LOGO 1
#else
#define HAS_BINARY_LOGO 0
#endif

TubePreampPluginAudioProcessorEditor::TubePreampPluginAudioProcessorEditor(
    TubePreampPluginAudioProcessor& p, juce::AudioProcessorValueTreeState& vts)
    : AudioProcessorEditor(&p), processor(p), state(vts)
{
    setSize(600, 440);

    // Start valve animation
    driveParam = state.getRawParameterValue("drive");
    startTimerHz(30);

    // Try to load logo image from binary resources first, fallback to file
    // BinaryData is generated by Projucer when resource="1" in the .jucer
   #if HAS_BINARY_LOGO
    {
        int dataSize = 0;
        if (const void* data = BinaryData::getNamedResource("logo_png", dataSize))
        {
            juce::MemoryInputStream mis(data, static_cast<size_t>(dataSize), false);
            logo = juce::ImageFileFormat::loadFrom(mis);
        }
    }
   #endif

    auto loadImageFromFile = [](const juce::File& f) -> juce::Image {
        if (f.existsAsFile())
        {
            juce::FileInputStream fis(f);
            if (fis.openedOk())
                return juce::ImageFileFormat::loadFrom(fis);
        }
        return {};
    };

    // Common candidate locations for development time
    const juce::String relPath = "resources/logo.png";
    if (! logo.isValid())
        logo = loadImageFromFile(juce::File::getCurrentWorkingDirectory().getChildFile(relPath));
    if (! logo.isValid())
        logo = loadImageFromFile(juce::File::getCurrentWorkingDirectory().getParentDirectory().getChildFile(relPath));
    if (! logo.isValid())
    {
        auto appDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
        logo = loadImageFromFile(appDir.getChildFile(relPath));
        if (! logo.isValid())
            logo = loadImageFromFile(appDir.getParentDirectory().getChildFile(relPath));
    }

    // Drive Slider
    driveSlider.setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
    driveSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 16);
    driveSlider.setLookAndFeel(&vintageLNF);
    {
        juce::Slider::RotaryParameters rp;
        rp.startAngleRadians = juce::MathConstants<float>::pi * 1.25f; // ~225°
        rp.endAngleRadians   = juce::MathConstants<float>::pi * 2.75f; // ~495°
        rp.stopAtEnd         = true;
        driveSlider.setRotaryParameters(rp);
    }
    // Improve midrange control around ~2.5 on 0.1..10
    driveSlider.setSkewFactorFromMidPoint(2.5);
    driveSlider.setVelocityBasedMode(true);
    driveSlider.setVelocityModeParameters(1.0, 1, 0.07, true);
    driveSlider.setMouseDragSensitivity(220);
    driveSlider.setPopupDisplayEnabled(true, false, this);
    driveSlider.setDoubleClickReturnValue(true, 1.0);
    addAndMakeVisible(driveSlider);
    driveAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "drive", driveSlider);

    // Drive Label
    driveLabel.setText("DRIVE", juce::dontSendNotification);
    driveLabel.setJustificationType(juce::Justification::centred);
    driveLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(driveLabel);

    // Output Slider
    outputSlider.setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
    outputSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 16);
    outputSlider.setLookAndFeel(&vintageLNF);
    {
        juce::Slider::RotaryParameters rp;
        rp.startAngleRadians = juce::MathConstants<float>::pi * 1.25f;
        rp.endAngleRadians   = juce::MathConstants<float>::pi * 2.75f;
        rp.stopAtEnd         = true;
        outputSlider.setRotaryParameters(rp);
    }
    // Improve fine control near 0.5 on 0..1
    outputSlider.setSkewFactorFromMidPoint(0.5);
    outputSlider.setVelocityBasedMode(true);
    outputSlider.setVelocityModeParameters(1.0, 1, 0.07, true);
    outputSlider.setMouseDragSensitivity(220);
    outputSlider.setPopupDisplayEnabled(true, false, this);
    outputSlider.setDoubleClickReturnValue(true, 0.8);
    addAndMakeVisible(outputSlider);
    outputAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "output", outputSlider);

    // Output Label
    outputLabel.setText("OUTPUT", juce::dontSendNotification);
    outputLabel.setJustificationType(juce::Justification::centred);
    outputLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(outputLabel);

    // Bias Slider
    biasSlider.setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
    biasSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 50, 16);
    biasSlider.setLookAndFeel(&vintageLNF);
    {
        juce::Slider::RotaryParameters rp;
        rp.startAngleRadians = juce::MathConstants<float>::pi * 1.25f;
        rp.endAngleRadians   = juce::MathConstants<float>::pi * 2.75f;
        rp.stopAtEnd         = true;
        biasSlider.setRotaryParameters(rp);
    }
    biasSlider.setVelocityBasedMode(true);
    // Ajustado para melhor controle fino: menor sensibilidade, threshold mais alto, sem offset
    biasSlider.setVelocityModeParameters(0.5, 3, 0.0, true);
    // Aumentada a sensibilidade de drag para movimentos mais suaves e precisos
    biasSlider.setMouseDragSensitivity(350);
    biasSlider.setPopupDisplayEnabled(true, false, this);
    biasSlider.setDoubleClickReturnValue(true, 0.0);
    // Configurar para mostrar 3 casas decimais para melhor precisão na exibição
    biasSlider.setNumDecimalPlacesToDisplay(3);
    // Função personalizada para formatação do texto com precisão adequada
    biasSlider.textFromValueFunction = [](double value) {
        return juce::String(value, 3);
    };
    // Melhorado o snap-to-center com janela menor e mais precisa
    biasSlider.onValueChange = [this]
    {
        if (biasSlider.isMouseButtonDown())
        {
            auto v = biasSlider.getValue();
            
            if (std::abs(v) < 0.01 && v != 0.0)
                biasSlider.setValue(0.0, juce::dontSendNotification);
        }
    };
    addAndMakeVisible(biasSlider);
    biasAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(state, "bias", biasSlider);

    // Bias Label
    biasLabel.setText("BIAS", juce::dontSendNotification);
    biasLabel.setJustificationType(juce::Justification::centred);
    biasLabel.setColour(juce::Label::textColourId, juce::Colours::white);
    addAndMakeVisible(biasLabel);
}

TubePreampPluginAudioProcessorEditor::~TubePreampPluginAudioProcessorEditor()
{
    stopTimer();
    driveSlider.setLookAndFeel(nullptr);
    outputSlider.setLookAndFeel(nullptr);
    biasSlider.setLookAndFeel(nullptr);
}

void TubePreampPluginAudioProcessorEditor::paint(juce::Graphics& g) {
    // Ensure/paint velvet background
    if (velvetBackground.getWidth() != getWidth() || velvetBackground.getHeight() != getHeight())
        regenerateVelvetBackground();
    if (velvetBackground.isValid())
        g.drawImageAt(velvetBackground, 0, 0);
    else
        g.fillAll(juce::Colour::fromRGB(18, 12, 38)); // deep indigo fallback

    // Header/title area, text centered but avoiding actual logo/tube bounds
    auto inner = getLocalBounds().reduced(20);
    auto header = inner.removeFromTop(160);

    g.setColour(juce::Colours::white);
    g.setFont(26.0f);

    // Compute actual reserved widths (replicate draw logic)
    int leftReserve = 0;
    if (logo.isValid())
    {
        const int marginL = 1;
        const int imgW = logo.getWidth();
        const int imgH = logo.getHeight();
        const int maxW = juce::jmin(300, (header.getWidth() * 2) / 3);
        const int maxH = juce::jmax(1, header.getHeight() - 2 * marginL);
        const float scale = std::min(maxW / (float) imgW, maxH / (float) imgH);
        const int drawW = juce::jmax(1, (int) std::round(imgW * scale));
        leftReserve = drawW + marginL + 6;
    }
    const int marginR = 6;
    const int tw = juce::jmin(180, header.getWidth() / 2);
    const int th = juce::jmin(150, header.getHeight() - 2 * marginR);
    juce::ignoreUnused(th);
    const int rightReserve = tw + marginR + 6;

    auto titleArea = header;
    titleArea.removeFromLeft(leftReserve);
    titleArea.removeFromRight(rightReserve);

    // Ensure the title always has enough width; if not, reclaim from sides
    const juce::String titleText = "VARvulado";
    const float titleW = g.getCurrentFont().getStringWidthFloat(titleText) + 20.0f;
    if ((float) titleArea.getWidth() < titleW)
    {
        int deficit = (int) std::ceil(titleW - (float) titleArea.getWidth());
        int giveL = juce::jmin(leftReserve, deficit / 2);
        int giveR = juce::jmin(rightReserve, deficit - giveL);
        auto expanded = header;
        expanded.removeFromLeft(leftReserve - giveL);
        expanded.removeFromRight(rightReserve - giveR);
        titleArea = expanded;
    }

    g.drawFittedText(titleText, titleArea, juce::Justification::centred, 1);
}

void TubePreampPluginAudioProcessorEditor::paintOverChildren(juce::Graphics& g)
{
    if (logo.isValid())
    {
        // Draw logo almost flush with the top-left corner
        const int margin = 1;
        auto outer = getLocalBounds();
        auto header = outer.removeFromTop(120);

        const int imgW = logo.getWidth();
        const int imgH = logo.getHeight();

        const int maxW = juce::jmin(300, (header.getWidth() * 2) / 3); // allow wider logo
        const int maxH = juce::jmax(1, header.getHeight() - 2 * margin);

        const float scale = std::min(maxW / (float) imgW, maxH / (float) imgH);
        const int drawW = juce::jmax(1, (int) std::round(imgW * scale));
        const int drawH = juce::jmax(1, (int) std::round(imgH * scale));

        const int x = header.getX() + margin;
        const int y = header.getY() + margin;

        drawLogoBlended(g, { x, y, drawW, drawH });
    }

    // Tube valve (top-right within header)
    {
        const int margin = 6;
        auto outer = getLocalBounds();
        auto header = outer.removeFromTop(160);
        const int tw = juce::jmin(180, header.getWidth() / 2);   // wider valve
        const int th = juce::jmin(150, header.getHeight() - 2 * margin); // taller valve
        juce::Rectangle<int> tubeArea(header.getRight() - tw - margin,
                                      header.getY() + (header.getHeight() - th) / 2,
                                      tw, th);
        drawTubeValve(g, tubeArea);
    }
}

void TubePreampPluginAudioProcessorEditor::resized() {
    auto bounds = getLocalBounds().reduced(20);
    auto header = bounds.removeFromTop(160); // reserved for logo + title + tube
    juce::ignoreUnused(header);

    // Controls area
    auto area = bounds.reduced(10);
    const int labelH = 18;
    const int columns = 3;
    int gap = 24; // start with a comfortable gap

    const int areaW = area.getWidth();
    const int areaH = area.getHeight();
    auto computeColW = [&](int g) { return (areaW - (columns - 1) * g) / columns; };

    int colW = computeColW(gap);
    if (colW < 150) { gap = 16; colW = computeColW(gap); }
    if (colW < 150) { gap = 8;  colW = computeColW(gap); }
    colW = juce::jmax(colW, 120);

    const int padX = 10;
    const int knobMaxByWidth  = colW - padX * 2;
    const int knobMaxByHeight = areaH - labelH - 30;
    const int knobSize = juce::jlimit(110, 180, juce::jmin(knobMaxByWidth, knobMaxByHeight));

    // Recalculate colW to match chosen knobSize
    colW = knobSize + padX * 2;
    const int totalW = columns * colW + (columns - 1) * gap;
    const int startX = area.getX() + juce::jmax(0, (areaW - totalW) / 2);
    const int topY = area.getY();

    auto place = [&](juce::Label& lbl, juce::Slider& s, int idx) {
        juce::Rectangle<int> col(startX + idx * (colW + gap), topY, colW, areaH);
        lbl.setBounds(col.removeFromTop(labelH));
        col.reduce(padX, 6);
        col.setSize(col.getWidth(), knobSize + 26); // knob plus textbox space
        s.setBounds(col);
    };

    place(driveLabel, driveSlider, 0);
    place(outputLabel, outputSlider, 1);
    place(biasLabel, biasSlider, 2);
}

void TubePreampPluginAudioProcessorEditor::drawLogoBlended(juce::Graphics& g, juce::Rectangle<int> dst)
{
    if (! logo.isValid())
        return;

    const int w = juce::jmax(1, dst.getWidth());
    const int h = juce::jmax(1, dst.getHeight());

    // Prepare scaled logo with high-quality resampling
    juce::Image scaled(juce::Image::ARGB, w, h, true);
    {
        juce::Graphics sg(scaled);
        sg.setImageResamplingQuality(juce::Graphics::highResamplingQuality);
        sg.drawImage(logo, juce::Rectangle<float>(0, 0, (float) w, (float) h));
    }

    // If velvet background exists, blend per-pixel to integrate tones
    const bool canBlend = velvetBackground.isValid();

    if (! canBlend)
    {
        g.drawImageAt(scaled, dst.getX(), dst.getY());
        return;
    }

    juce::Image blended(juce::Image::ARGB, w, h, true);

    for (int y = 0; y < h; ++y)
    {
        for (int x = 0; x < w; ++x)
        {
            const juce::Colour s = scaled.getPixelAt(x, y);
            const int bx = juce::jlimit(0, velvetBackground.getWidth()  - 1, dst.getX() + x);
            const int by = juce::jlimit(0, velvetBackground.getHeight() - 1, dst.getY() + y);
            const juce::Colour b = velvetBackground.getPixelAt(bx, by);

            float a = s.getFloatAlpha();
            float sr = s.getFloatRed();
            float sg = s.getFloatGreen();
            float sb = s.getFloatBlue();

            // Suppress blue fringing only near edges (very gentle)
            const float maxRG = std::max(sr, sg);
            float blueFringe = juce::jlimit<float>(0.0f, 1.0f, (sb - maxRG - 0.08f) * 0.8f);

            // Edge metrics
            const int edgePx = 2;
            const int minEdge = std::min(std::min(x, y), std::min(w - 1 - x, h - 1 - y));
            const float edgeFactor = minEdge < edgePx ? (edgePx - (float) minEdge) / (float) edgePx : 0.0f; // 0..1
            const float edgeFeather = minEdge < 1 ? (1.0f - (float) minEdge) : 0.0f; // 0..1

            a = a * (1.0f - 0.20f * blueFringe * edgeFactor) * (1.0f - 0.04f * edgeFeather);
            a = juce::jlimit<float>(0.0f, 1.0f, a * 1.25f + 0.08f); // stronger alpha boost with floor

            // Multiply blend to inherit velvet tone
            float br = b.getFloatRed();
            float bg = b.getFloatGreen();
            float bb = b.getFloatBlue();

            // Pre-boost logo more to avoid looking washed out
            sr = juce::jlimit<float>(0.0f, 1.0f, sr * 1.12f + 0.02f);
            sg = juce::jlimit<float>(0.0f, 1.0f, sg * 1.12f + 0.02f);
            sb = juce::jlimit<float>(0.0f, 1.0f, sb * 1.12f + 0.02f);

            // Use normal blend colours (no multiply/screen) for maximum visibility
            float cr = sr;
            float cg = sg;
            float cb = sb;

            float rr = br * (1.0f - a) + cr * a;
            float rg = bg * (1.0f - a) + cg * a;
            float rb = bb * (1.0f - a) + cb * a;

            blended.setPixelAt(x, y, juce::Colour::fromFloatRGBA(rr, rg, rb, 1.0f));
        }
    }

    // Stronger backplate to seat the logo (darken background slightly)
    g.setColour(juce::Colours::black.withAlpha(0.20f));
    g.fillRoundedRectangle(dst.toFloat().expanded(2.0f), 4.0f);

    g.drawImageAt(blended, dst.getX(), dst.getY());
}

void TubePreampPluginAudioProcessorEditor::timerCallback()
{
    // Animate flicker phase
    tubeAnimPhase += 0.07f;
    if (tubeAnimPhase > juce::MathConstants<float>::twoPi)
        tubeAnimPhase -= juce::MathConstants<float>::twoPi;

    // Gradual heat response: start after ~0.7 drive, smooth over time
    if (driveParam != nullptr)
    {
        const float dv = juce::jlimit<float>(0.1f, 5.0f, *driveParam);
        const float th = 0.7f;                   // threshold to start glowing
        float target = 0.0f;
        if (dv > th)
        {
            const float tLin = (dv - th) / (5.0f - th);       // 0..1 from threshold to max
            target = std::pow(juce::jlimit<float>(0.0f, 1.0f, tLin), 1.6f); // ease-in for gradual rise
        }
        // Low-pass filter toward target for smooth visual response
        const float alpha = 0.12f;   // smoothing factor per frame (~30fps)
        tubeHeat += (target - tubeHeat) * alpha;
    }
    repaint();
}

void TubePreampPluginAudioProcessorEditor::drawTubeValve(juce::Graphics& g, juce::Rectangle<int> area)
{
    if (area.isEmpty()) return;

    const float w = (float) area.getWidth();
    const float h = (float) area.getHeight();
    const auto c = area.getCentre().toFloat();
    juce::ignoreUnused(c);

    // Effective heat: gradual base from timer + flicker modulation
    const float flicker = 0.92f + 0.12f * std::sin(tubeAnimPhase * 3.0f) + 0.06f * std::sin(tubeAnimPhase * 5.2f);
    const float heat = juce::jlimit<float>(0.0f, 1.3f, (0.08f + 1.05f * tubeHeat) * flicker);

    // Backplate shadow
    g.setColour(juce::Colours::black.withAlpha(0.22f));
    g.fillRoundedRectangle(area.toFloat().expanded(2.0f), 6.0f);

    // Glass bulb
    {
        juce::Rectangle<float> glass(area.toFloat());
        glass.reduce(w * 0.10f, h * 0.06f);
        auto top = glass.removeFromTop(glass.getHeight() * 0.86f);
        auto base = glass; // remainder
        glass = top.expanded(0.0f, base.getHeight() * 0.2f);

        juce::Colour glassHi = juce::Colour::fromRGBA(220, 230, 255, 90);
        juce::Colour glassLo = juce::Colour::fromRGBA(40, 60, 90, 70);
        juce::ColourGradient grad(glassHi, glass.getX(), glass.getY(), glassLo, glass.getRight(), glass.getBottom(), true);
        g.setGradientFill(grad);
        g.fillEllipse(glass);
        g.setColour(juce::Colours::white.withAlpha(0.28f));
        g.drawEllipse(glass, 1.0f);

        // highlight streak
        g.setColour(juce::Colours::white.withAlpha(0.12f));
        g.fillEllipse(glass.withSizeKeepingCentre(glass.getWidth() * 0.18f, glass.getHeight() * 0.9f)
                          .translated(-glass.getWidth() * 0.26f, -glass.getHeight() * 0.05f));
    }

    // Electrodes and heater
    {
        juce::Path plates;
        const float plateW = w * 0.22f;
        const float plateH = h * 0.38f;
        const float plateY = area.getY() + h * 0.30f;
        plates.addRoundedRectangle(area.getCentreX() - plateW - 3.0f, plateY, plateW, plateH, 3.0f);
        plates.addRoundedRectangle(area.getCentreX() + 3.0f, plateY, plateW, plateH, 3.0f);
        g.setColour(juce::Colour::fromRGB(60, 60, 66));
        g.fillPath(plates);
        g.setColour(juce::Colours::black.withAlpha(0.5f));
        g.strokePath(plates, juce::PathStrokeType(1.0f));

        // Heater glow region at bottom
        juce::Rectangle<float> heater((float) area.getX() + w * 0.24f,
                                      (float) area.getY() + h * 0.62f,
                                      w * 0.52f, h * 0.14f);
        juce::Colour hot1 = juce::Colour::fromFloatRGBA(1.0f, 0.55f, 0.10f, juce::jlimit<float>(0.12f, 0.75f, heat * 0.75f));
        juce::Colour hot2 = juce::Colour::fromFloatRGBA(1.0f, 0.86f, 0.40f, juce::jlimit<float>(0.18f, 0.95f, heat * 0.95f));
        juce::ColourGradient glow(hot2, heater.getCentreX(), heater.getY(), hot1, heater.getCentreX(), heater.getBottom(), false);
        g.setGradientFill(glow);
        g.fillRoundedRectangle(heater, 6.0f);

        // Additional halo
        juce::Colour halo = juce::Colour::fromFloatRGBA(1.0f, 0.6f, 0.15f, juce::jlimit<float>(0.0f, 0.50f, heat * 0.50f));
        g.setColour(halo);
        for (int i = 0; i < 3; ++i)
            g.fillEllipse(heater.expanded(h * (0.05f + 0.03f * i)));
    }

    // Base/socket with pins
    {
        juce::Rectangle<float> sock((float) area.getX() + w * 0.18f,
                                    (float) area.getBottom() - h * 0.16f,
                                    w * 0.64f, h * 0.14f);
        juce::Colour s0(30, 30, 36), s1(70, 70, 78);
        juce::ColourGradient sg(s1, sock.getX(), sock.getY(), s0, sock.getRight(), sock.getBottom(), true);
        g.setGradientFill(sg);
        g.fillRoundedRectangle(sock, 4.0f);
        g.setColour(juce::Colours::black.withAlpha(0.5f));
        g.drawRoundedRectangle(sock, 4.0f, 1.0f);

        // Pins
        g.setColour(juce::Colour::fromRGB(180, 162, 90));
        const int pins = 4;
        for (int i = 0; i < pins; ++i)
        {
            float t = (i + 0.5f) / pins;
            float px = sock.getX() + t * sock.getWidth();
            g.fillRect(px - 1.0f, sock.getBottom(), 2.0f, h * 0.08f);
        }
    }
}

void TubePreampPluginAudioProcessorEditor::regenerateVelvetBackground()
{
    const int w = juce::jmax(1, getWidth());
    const int h = juce::jmax(1, getHeight());
    velvetBackground = juce::Image(juce::Image::RGB, w, h, true);

    // Parameters for velvet-like folds (vertical drapes)
    const int folds = 6;
    const float sigma = w / (folds * 3.0f); // width of highlights
    juce::Array<float> foldCenters;
    for (int i = 0; i < folds; ++i)
        foldCenters.add((i + 0.5f) * (w / (float) folds));

    // Precompute fold profile across X
    juce::HeapBlock<float> profile(w);
    float maxProf = 0.0f;
    for (int x = 0; x < w; ++x)
    {
        float s = 0.0f;
        for (auto c : foldCenters)
        {
            const float dx = (x - c);
            s += std::exp(-(dx * dx) / (2.0f * sigma * sigma));
        }
        profile[x] = s;
        if (s > maxProf) maxProf = s;
    }
    if (maxProf <= 0.0f) maxProf = 1.0f;

    // Deterministic seed for grain; use valid hex literal
    juce::Random rng((juce::int64) 0xB1DEA1);

    // Base and highlight colours (deep purple-blue)
    const juce::Colour base = juce::Colour::fromFloatRGBA(0.07f, 0.04f, 0.18f, 1.0f); // deep indigo
    const juce::Colour hi   = juce::Colour::fromFloatRGBA(0.20f, 0.12f, 0.45f, 1.0f); // purple-blue highlight

    for (int y = 0; y < h; ++y)
    {
        // Subtle vertical gradient (vignette top/bottom)
        const float vy = (y / (float) h);
        const float vignetteY = 0.85f + 0.15f * std::cos((vy - 0.5f) * juce::MathConstants<float>::twoPi);

        for (int x = 0; x < w; ++x)
        {
            float fx = profile[x] / maxProf;              // 0..1 highlight factor
            float grain = (rng.nextFloat() - 0.5f) * 0.06f; // fine noise
            if ((y & 1) == 0) grain *= 0.6f;               // slight anisotropy

            // Sheen: simulate angle-dependent highlight
            const float sheen = 0.15f * std::sin((x * 0.012f) + (y * 0.02f));

            float shade = juce::jlimit<float>(0.0f, 1.4f, 0.55f + 0.45f * fx);
            shade = shade * vignetteY + sheen + grain;
            shade = juce::jlimit<float>(0.0f, 1.2f, shade);

            // Mix base and highlight by shade
            const int r = juce::jlimit(0, 255, (int) std::round(base.getRed()   * (1.0f - shade) + hi.getRed()   * shade));
            const int g = juce::jlimit(0, 255, (int) std::round(base.getGreen() * (1.0f - shade) + hi.getGreen() * shade));
            const int b = juce::jlimit(0, 255, (int) std::round(base.getBlue()  * (1.0f - shade) + hi.getBlue()  * shade));

            velvetBackground.setPixelAt(x, y, juce::Colour::fromRGB((juce::uint8) r, (juce::uint8) g, (juce::uint8) b));
        }
    }

    // Overlay a soft diagonal highlight and corner vignettes
    {
        juce::Graphics gg(velvetBackground);

        juce::ColourGradient diag(juce::Colours::transparentBlack, {0.0f, 0.0f},
                                  juce::Colour(255, 255, 255).withAlpha(0.05f), { (float) w, (float) h }, false);
        gg.setGradientFill(diag);
        gg.fillAll();

        juce::ColourGradient vign(juce::Colours::black.withAlpha(0.16f), {0.0f, 0.0f},
                                  juce::Colours::transparentBlack, { (float) w * 0.6f, (float) h * 0.6f }, true);
        gg.setGradientFill(vign);
        gg.fillEllipse(-w * 0.2f, -h * 0.2f, w * 0.8f, h * 0.8f);

        juce::ColourGradient vign2(juce::Colours::black.withAlpha(0.16f), { (float) w, (float) h },
                                   juce::Colours::transparentBlack, { (float) w * 0.4f, (float) h * 0.4f }, true);
        gg.setGradientFill(vign2);
        gg.fillEllipse(w * 0.4f, h * 0.4f, w * 0.8f, h * 0.8f);
    }
}
